Python Notes:

-- Variables Assignment:

- Variables names should be in lower case.
- White spaces are not allowed instead use _
- Python uses dynamic typing which means that any variable can be reassign to different datatype.
- to check datatype of variables in python use type() function.

--Strings in python:
- Strings are ordered collection of characters.
- Indexing [] and slicing can be done.
- Reverse indexing is also possible, it means last character will be -(strLength-1)
- Slicing allows to grabs some section of the string.
- Its syntax is as follows
    [start:stop:step]
    - start: numerical index for slice starting
    - stop: index value you will go to, but excluding it
    - step: size of jump you take.
- In python we can use escape sequence diretly inside '' and ""., example 
    print("Hello \nWorld")
    o/p - Hello
        World
- len() function is used to get length of string.

-- Indexing and Slicing with strings:
-Reverse indexing starts with index -1 because in reverse indexing 0 is considered 1st character of the string.
- step value in [start:end:step] ignores that number of character from starting point and prints the next character
    example> mystring = 'abcdefghij'
            mystring[::2]
            o/p: acegj
- we can print whole string as follows 
    mystring[:] or mystring[::]
- To reverse string use: mystring[::-1]

-- String Properties and Methods
- String are immutables i.e we cannot change character using index assignment.
- To grab each word of string in a list use slipt() method as:
>>> mystring = "Hello World"
>>> mystring.split()
['Hello', 'World']
- slpit() method splits the string using whitespaces if not character is provided.
- use hashtag # to comment line in code.

-- Print formatting with strings:
- string.format() method is used to format string
- syntax is as follows
  'something {} something {}'.format('str1', str2)
- In {} we can use index for altering position of string.
- Also we can assign variables/ keyword in {} as follows:
>>> print('{} is my {}'.format('India', 'country'))
India is my country
>>> print('{0} is my {1}'.format('India', 'country'))
India is my country
>>> print('{1} is my {1}'.format('India', 'country'))
country is my country
>>> print('{1} is my {1}'.format(i = 'India', c = 'country'))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
>>> print('{i} is my {c}'.format(i = 'India', c = 'country'))
India is my country
>>> ind = 'India'
>>> cnty = 'country'
>>> print('{} is my {}'.format(ind, cnty))
India is my country
>>>

- Floating point precision can also be formatted using following syntax:
  {value:width.precision f}
  width: number of digit to be printed before precision, extra withspace is added if no digit present.
  precisiion: number of digits to be printed after . in rounding manner

>>> result = 100/777
>>> print('Result is {}'.format(result))
Result is 0.1287001287001287
>>> print('Result is {r}'.format(r = result))
Result is 0.1287001287001287
>>> print('Result is {r:3.3f}'.format(r = result))
Result is 0.129

- Another method for string formatting and interpolation is f string method:
>>> print(f'{ind} is my {cnty}')
India is my country
>>> print(f'Result is {result:3.3f}')
Result is 0.129


--List in Python
- LIST is ordered sequence that holds variety of object types.
- Indexing and slicing is possible.
- Elements are comma seperated.
- All method that we use for string can be implemented in list also.
- Difference between string and list is that list are mutable i.e, we can change any element in list using index operator.
>>> my_list = ['Sanket', 17, 90.9, True]
>>> my_list
['Sanket', 17, 90.9, True]
>>> len(my_list)
4
>>> my_list.append('One')
>>> my_list
['Sanket', 17, 90.9, True, 'One']
>>> my_list.pop()
'One'
>>> my_list
['Sanket', 17, 90.9, True]
>>> my_list.pop(2)
90.9
>>> my_list
['Sanket', 17, True]
>>> my_list[3] = 'One'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
>>> 

- append() method is used to add an element at the end of the list.
- pop() method is used to remove last element from the list.
- If we provide index in pop() element on that index will be removed, hence default index for pop() is -1.
- sort() function is used to sort the element in the element in place i.e, sort() doesnot return any new list, it performs action in the same list.
- sort() is performed if all the elements in the list are of same type.
- reverse() function is used to reverse list in decending format. It also performs in place reversing.

--Dictionaries in Python
-Dictionaries are unordered mappings for storing objets.
- Data is stored in key-value pair, key-value pair advantage is that it grabs data quickly than that of indexes.
- They are unordered and cannot be sorted.
- Syntax for dictionaries are:
  my_dict = {'key1': 'value1', 'key2':'value2'}
- Dictionaries key can hold any kind of data like basic datatypes, list and another dictionaries itself.
- dict.keys() method returns all keys in the dictionaries.
- dict.values() method returns all values in the dictionaries.
- dict.items() method returns all keys-value pairs in the dictionaries.
>>> my_dict = {'key1': 100, 'key2': [1,2,3], 'key3': {'in': True, 'out': False}}
>>> my_dict
{'key1': 100, 'key2': [1, 2, 3], 'key3': {'in': True, 'out': False}}
>>> len(my_dict)
3
>>> my_dict.keys()
dict_keys(['key1', 'key2', 'key3'])
>>> my_dict.valuess()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'dict' object has no attribute 'valuess'
>>> my_dict.values()
dict_values([100, [1, 2, 3], {'in': True, 'out': False}])
>>> my_dict.items()
dict_items([('key1', 100), ('key2', [1, 2, 3]), ('key3', {'in': True, 'out': False})])
>>> my_dict['key3']['out']
False

--Tuples with Pyhton
- Tuples are very similar to that of list.
- Main difference is that they are immutable.
- Once element is inside tuple it cannot be reassigned.
- Tuples uses parenthesis: (1,2,3)
- All index and slicing operation that are performed on list can also be performed on tuples.
- tuple.count(element) method returns count of occurance of 'element' in tuple.
- tuple.index(element) method returns index of first occurance of 'element' in tuple.
>>> mytuple = (3,5,7,1)
>>> mytuple
(3, 5, 7, 1)
>>> mytuple.sort()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'tuple' object has no attribute 'sort'
>>> mytuple.count(1)
1
>>> mytuple.index(1)
3
>>> mytuple[0:3]
(3, 5, 7)
>>> mytuple[0:3:2]
(3, 7)
>>> mytuple[::]
(3, 5, 7, 1)

--Sets in Python
- Sets are unordered collection of unique elements.
- There can be only one set of object at a time.
- Sets are created using set() function.
- Set are represented using {} the only difference is that dictionaries contains key-value pair.
- Elements are added in the set using add() method.
>> myset = set()
>>> myset.add(1)
>>> myset
{1}
>>> myset.add(2)
>>> myset
{1, 2}
>>> myset.add(2)
>>> myset
{1, 2}
>>> my_set_list = [1,1,1,2,2,2,3,3]
>>> set(my_set_list)
{1, 2, 3}

--Boolean in Python
- Booleans represent truth/false of expression or statements.
- In python, booleans are represented as True or False.
- type(True) is bool.
- In python when we don't want to assign variable any value, we can specify its type as None.

--I/O with basic files in Python
- To open a file in python use open() function.
- To read a file use read().
- To read lines in list format use readlines() method.
- To please file descriptor at starting point use seek() method.
- To close file use close() method.
- If we forget to close the file using close() method then we might get an error while externally accessing the file.
- This can be solved using following syntax.

with open('myfile.txt') as my_new_file:
    new_content = my_new_file.readlines()
    print(new_content)

- The  above syntax is similar to normal file operation.
- When the file is opened with the above syntax it is only accessible within its given scope.
- And after that scope file gets automatically closed.

Basic Practice:

http://codingbat.com/python

More Mathematical (and Harder) Practice:

https://projecteuler.net/archives

List of Practice Problems:

http://www.codeabbey.com/index/task_list

A SubReddit Devoted to Daily Practice Problems:

https://www.reddit.com/r/dailyprogrammer

A very tricky website with very few hints and touch problems (Not for beginners but still interesting)

http://www.pythonchallenge.com/


--Logical Operators in Python
- key logical operator keywords are: and or not

-- for loop
- Syntax:
  iterativeObj = something
  for tempvar in iterativeObj:
    print(tempvar)

-- while loops in Pyhton
- Syntax:
  while some_cond:
    #do something
  else:
    # only prints when some_cond is false
- break: Breaks out of current closest enclosing loop.
- continue: Goes to the top of closest enclosing loop.
- pass: Does nothing at all.
- Use of pass keyword: Following code gives error

for items in iterativeItem:
  # comment
  
- As we have inserted commet in the loop scope, python interpreter need a statement other that comment.
- Hence to solve this error we need to insert a placeholder.
- pass keyword can be inserted if we want to add a placeholder, so the above code can be modified as

for items in iterativeItem:
  # comment
  pass

-- Useful operator in python
- range(start, stop,[step]): Its is a generator operator.
- generators are special operator/function which generate data
- If we want to print element using indexes we can use enumrate operator
- enumerate() return a tuple which contains (indexNumber, element_at_that_index)
- zip(list1, list2) create a list of pair in form of tuples mapping value x from list1 with value y from list2 as (x,y)
- zip() create pair upto shortest length of any of the list provided.
- in operator is used to check whether a given value is present in list or dictionaries
- in operator returns boolean value.
>>> mylist = [1,2,3,4]
>>> mylist
[1, 2, 3, 4]
>>> 4 in mylist
True
>>> mytuple = (5,6,7)
>>> mytuple
(5, 6, 7)
>>> 6 in mytuple
True
>>> mydict = {'k1':1, 'k2':2}
>>> mydict
{'k1': 1, 'k2': 2}
>>> 1 in mydict
False
>>> k1 in mydict
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'k1' is not defined
>>> 'k1' in mydict
True
>>> 'k1' in mydict.items()
False
>>> 'k1' in mydict.keys()
True
>>> 2 in mydict.items()
False
>>> 2 in mydict.values()
True

- max() and min() function are used to fetch max and min values from given list/tuples
- shuffle() methods shuffle's list IN PLACE.
- random(start_limit, end_limit): is used to return a random number with specified range.
- input() function is used to get input from user in string format.
- int(), float(), str() are use for type conversion.

-- List comprehensions in python
- List comprehensions are unique way of quickly creating a list with python.
- Its implementation is given in LoopStatement.py file.

--Function in python
- Syntax:
    def function_name(arg):
        #function code

    function_name('something')
-Function name should be lower case and multi words should be seperated using _
- We must provide DOCSTRING which act as manual for user defined functions.
- it is defined in following manner:
  ,,,
  DOCSTRING: Information about function.
  INPUT: name of input args
  OUTPUT: expected output 
  '''

  -- *args and **kwargs in python
  - args - arguments
  - kwargs - keyword arguments

  -- Lambda Expression, Map and Filter Functions:
  - Lambda expression are basically used to create an anonymous function quickly which can be used only one time.
  - map(func, *iterableObj) - when we need to apply a function to every element in iterable object we just use map() function.
  - map() returns a new object whose every element has been applied with the function passed to map.
  - filter(func, *iterableObj) - when we need to extract a particular set of element from iterableObject which satisfies given function condn then we can use filter().
  - The func that we pass to filter() must return a boolean value.
  

--Nested statement and scope
- Python uses following rule for assign accessing variable:
LEBG Rule:
L: Local: variables assigned in function
E: Enclosing function locals - or nearest parent function scope.
G: Global(module) variable assigned at top level of file/module file or declared as 'global var' inside any function.
B: Built-In(Python) - Names preassigned in the built-in names modules: open, range, SyntaxError..

following is example of scoping

#Global
x = 100

def greet():
  #Enclosing
  x = 200

  def sayHello():
    #Local
    x = 300
    print(x)
- To access global variable in greet() use 
  global x 


-- Object Oriented Programming in Python
- Following is the syntax to create class:

  class MyClassName:
    def __init__(self, att):
      self.att = att
    
    def some_method(self):
      self.att = True

- Class name should be Pascal case.
- __int__ is called constructor.
- self is similar to this.
- For each method we need to pass reference of this
- Class Object Attribute - This are attribute that are share common value for every object created.
- They are defined above __init__method.
- They are reference using self.varName or ClassName.varName
- We can also pass default parameter for any method we define as well as for init().

-- Inheritance and Polymorphism
- To inherit a base class use follow syntax:
  class DerivedClass(BaseClass):
      def __init__(self):
        #Derived class constructor
        BaseClass.__init__(self) #Base class constructor

      #Derived class method
- We can call/override base class method using derived class instance

-- Special Magic/Dunder Methods
- len(), print(), str(), del keyword are generic methods.
- We can use this method with list, set, tuples etc.
- But when we use them with object the give out error.
- Hence in order to use these method with our object we can use special method called as magic or dunder method.
- This method start and end with __(double underscore).
- __str__ - method is used to print out string representation of our object.
- __len__ function can be used to print out any numerical value representing that object.
- __del__ function is used to perform some extra operation needs to be perform while deleting the object.

-- Modules and Packages in Python
-PyPI is a repository for open-source third-party Pyhton Packages.
- It is similar to npm for nodejs.
- Modules is just a .py script that you call in another .py script.
- Packages are collection of modules.-
- To create a package add __init__.py.
- This is an empty file.
- To import this package use follow syntax:
  from FolderName import FileName

  FileName.functionName()

  -- __name__ and __main__
  - When ever we run our file "__main__" string is assigned to "__name__" variable.
  - It is a built-in varible of Python,
  - Using this variable we can check whether a module is run or is imported from another package.

  -- Error and Exception handling
  - Eror handling is similar to that of in another programming languages used.
  - We have try-except-else-finally block.
  - try block is a block where we test our code for error.
  - except block is triggered when we get an error in try block.
  - else block is followed after except block, this block is executed when we get no error in try block.
  - And finally block is executed after the execution of except or else block.

-- PyLint Overview
- For testing we use following tools:
- Pylint: This is a library that looks at your code and report back possible issues. Issues basically related to indentation, styling and variable assignment.
- unittest - This built-in library  will allow you to test your own programs and check are you getting desired outputs.
- Python has a set of style convention rules known as 'PEP8'.
- To run a pylint use below command:
  pylint program-name.py
- To improve our rating of pylint use below tips:
 - Add DOCSTRING at the begin of any module.
 - Add DOCSTRING for every user-defined function.
 - Add new line at eof
- unittesting demo is given in unitTesting.py file.

-- Decorators in Python
- Decorator allows you to decorate your function.
- Suppose we have a function say hello(), we need to add some functionality to it.
- One way is that we write a new function, another way is that we can manually add/remove extra functionality code.
- So Decorator allow us to add this functionality in the form of on/off button.
- In python, we can define a function inside a function.
- We can also return a function from another function.
- Functions are object in pyhton.
- Consider the following example:
  def hello():
    print('Hello World')

  hello()
  print(hello) //<function hello at 0x7f358895e668>

  greet = hello

  del hello
  greet() // Heelo World
  hello() // error

- Hence from above example it is clear that functions are object in Python.
- As we know that we can pass/return any function from any another function.
def original_func():
    print('This is original function')

def decorator_func(some_func):
    def wrapper_func():
        print('This is starting of wrapper function')
        some_func()
        print('This is end of wrapper function')

    return wrapper_func

new_decorated_func = decorator_func(original_func)
new_decorated_func()

# The above function can also be decorated as:
print('After adding @ operator')
@decorator_func
def original_func():
    print('This is original function')

original_func()

print('After removing @ operator')
# @decorator_func
def original_func():
    print('This is original function')

original_func()

- @ operator as used above helps original func to add/remove extra functionality that we want to implement.

--Generators with Python
- Generator function allows us to write a function that can send back a value and then latter resume to pick up where it left off.
- Generator function generates value of a specific range.
- They have some iterating protocal on them.
- When we want to generate a series of values we can manually used function.
- In this function we generate list of value. This list is stored in memory.
- When we generate a value from generator it is not stored in memory.
- We can use yeild keyword to generate the individual element in series.
- generator.py file contains the example we convert a manual function into generator.
- next() function is used to fetch next element of generator.
- iter() function is used to convert string into generator so that they can access next() function.

-- Advanced Pyhton Modules
- Counter module
- It resides in collection package.
- Counter() gives count of each element in dictionary format:
>>> from collections import Counter
>>> l = [1,2,2,2,6,54654,643,6]

>>> Counter(l)
Counter({2: 3, 6: 2, 1: 1, 643: 1, 54654: 1})
>>> str_var = 'Hello'
>>> Counter(str_var)
Counter({'l': 2, 'H': 1, 'e': 1, 'o': 1})

>>> Counter(str_var).most_common()
[('l', 2), ('H', 1), ('e', 1), ('o', 1)]
>>> 

- defaultdict:
- Suppose we created a dictionaries and we try to access a value whose key is not present in dict.
- Then it will give us key error.
- When we use defaultdict, if we access un-avaialble key, it will not through key-error.

-OrderedDict
- When we create a dict and print it, it gets printed in unordered format.
- Consider the following example:
# ordered dict

mydict = {}
mydict['a'] = 1
mydict['b'] = 2
mydict['c'] = 3

for k,v in mydict.items():
    print(k, v)

from collections import OrderedDict

mydict = OrderedDict()
mydict['a'] = 1
mydict['b'] = 2
mydict['c'] = 3

print('After using ordered dict:\n')

for k,v in mydict.items():
    print(k, v)

-namedtuples
- When we create a tuple, each element in tuple is access using indexes.
- When we have larger number of element in tuples, it becomes hard to remember indexes of each element.
- So namedtuple is collection using which we can access element using names as well as indexes.
- When we create a namedtuple, we bascially create a class as follow:

var = namedtuple(classname, 'atrr1 attr2 attr3')

-- DateTime
- datetime is the module used for manipulating date and time in pyhton.
- datetime.datetime.now() method is used to print current date and time.
- datetime.time(h, m, sec, microsec, tzinfo) is used to create an instance of user specified time.
- datetime.date(year, month, day) is used to created an instance of user defined date.
- We can use, .hour, .minute ,.microsecond ,.year ,.month ,.day methods to get desired values from date time instance.
- datetime.replace(value=) method is used to replace/change the desired instance.
- We can aslo perform arithmatic operation on two different date instances.
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2019, 3, 25, 10, 5, 21, 453006)
>>> d1 = datetime.datetime.now()
>>> d1.hour
10
>>> d1.minute
7
>>> d1.second
34
>>> d1.microsecond
215486
>>> d1.year
2019
>>> d1.month
3
>>> d1.day
25
>>> d1.replace(day=17)
datetime.datetime(2019, 3, 17, 10, 7, 34, 215486)
>>> d1.replace(hour=1)
datetime.datetime(2019, 3, 25, 1, 7, 34, 215486)
>>> d2 = datetime.datetime.now()
>>> d2 - d1
datetime.timedelta(0, 560, 135671)

- datetime.today() is used to get current date.
- min, max, resolution is used to get minValue, Max value range and resolution(min difference) of datetime.

-- Python Debugger
- pdb is the python Debugger
- To use this debugger import pdb module.
- Use pdb.pdb.set_trace() method to set the debugger in the code.
- When we reach at debugger we can cross check the desired value.
- To quit from debugger when can press q.
- To continue execution to next line after debugger press c.
b: set a breakpoint
c: continue debugging until you hit a breakpoint
s: step through the code
n: to go to next line of code
l: list source code for the current file (default: 11 lines including the line being executed)
u: navigate up a stack frame
d: navigate down a stack frame
p: to print the value of an expression in the current context

-- Timing your code - timeit module
- Suppose we want to test the execution time of our code we can use timeit.timeit() method.
- We can use this in two ways 1st is using magic string and another is timeit.timit() method.
- timeit.timeit() method takes two arguments, 1st is expression in string that we want to test for timeit, and another is number= (no. of times we want to execute the statement)

-- Regular Expression - re
- RE is text matching expression.
- To use it we need to import re module
- To match a specific pattern in string we can use re.match(pattern, string).
- This method returns object of match result if found or send object of type None if nothing is matched.
- On the match object we can call start(), end() method get that starting and ending index of our matching pattern.
- The above methods returns start and end index of the 1st occurance of the match pattern.
- To split a string into list we can either use str.split() or re.split(pattern, phrase)
- This method returns list object of the slpitted list.

>>> import re
>>> result3 = re.match('Hello', 'Hello Hello')

>>> result3
<_sre.SRE_Match object; span=(0, 5), match='Hello'>
>>> result3.start()
0
>>> result3.end()
5
>>> result4 = re.findall('Hello', 'Hello Sam, Hello Tam, hello Jam')
>>> result4
['Hello', 'Hello']
>>> len(result4)
2

- re.findall() method is used to return all the instance of the matched pattern into list.
- Using len() on the above returned reult we can get the number of occurance of a particular pattern in the string.
- Regular Expression Repetition Syntax:

sd* - s followed by zero or more d's
sd+ - s followed by one or more d's
sd? - s followed by zero or one d
sd{3} - s followed by three d's
sd{2, 3} - s followed by two to three d's

- Regular Expression character sets:
- They are used when we wish to match any group of characters.
- This grouping is done using [] Operators
[sd] - either s or d
- We can also apply repetition syntax to character sets.

- Regular Expression Exclusion:
- To avoid matching of some characters from the string we can using exclusion operator.
- ^ is the operator used for exclusion.
s[^d]+ - exclude any positive match of character d

- Regular Expression Character Ranges:
- Sometimes specificing range of characters in character sets becomes tedious.
- Hence to avoid it we can use Character range expression.
- It is denoted using - character
[a-z]+ - sequence of lower case letters
[A-Z]+ - sequence of upper case letters
[a-zA-Z]+ - sequence of lower or upper case letters
[a-z][A-Z]+ - sequence of lower case followed by upper case letters

- Regular Expression escape code:
- Using escape codes we can find specific patterns in our data,digits, non-digits, whitespaces etc.
\d - digit
\D - non-digit
\s - whitespaces(tab, space, newline, etc..)
\S - non-whitespaces
\w - aplha-numeric
\W - non-alpha-numeric

-- String IO 
- String IO module implements an in-memory file like object. This object can be used as input or output to most functions that would expect a standard file object.
- We need to import StringIO module to use it.
- StringIO.StringIO(STR) is the method used to convert a normal string into in-memory file object.
- All file related operation can be applied over this object.

-- Advanced Python Object and data structure

- Advanced Numbers
>>> hex(32)
'0x20'
>>> bin(32)
'0b100000'
>>> 3**3
27
>>> pow(3,3)
27
>>> pow(3,3,1)
0
>>> abs(-1)
1
>>> round(3.141532, 3)
3.142
>>> 

- hex(decimal) - returns hexadecimal representation of that number.
- bin(decimal) - returns binary format represenation of that number.
- pow(x, y, z) - returns (x**y) % z
- abs() - returns absolute values.
- round(x, y) - returns round of value of x, y represent number of decimal digit to be displayed.

-Advanced String
>>> str1 = 'hello World'
>>> str1.capitalize()
'Hello world'
>>> str1.upper()
'HELLO WORLD'
>>> str1.lower()>>> str1.capitalize()
'Hello world'
>>> str1.upper()
'HELLO WORLD'
>>> str1.lower()
'hello world'
>>> str1.islower()
False

'hello world'
>>> str1.islower()
False

>>> str1.isalnum()
False
>>> str1.isalpha()
False
>>> str1
'hello World'
>>> str1.isalpha()
False
>>> str1.isspace()
False
>>> str1.istitle()
False
>>> str1.endswith('d')
True
>>> str2 = 'hihihpihihi'
>>> str2.split('i')
['h', 'h', 'hp', 'h', 'h', '']
>>> str2.partition('i')
('h', 'i', 'hihpihihi')
>>> str2.count('i')
5
>>> str2.find('p')
5


- capitalize() capitalizes first letter of the string.
- istitle() checks if the string is of type heading title
- partition() splits the string from the first occurance of the match.
- count() returns the number of occurance of given character in string.
- find() returns index of first occurance of given character.

-- Advanced Sets

>>> s = {1,2,3}
>>> sc = s.copy()
>>> sc
{1, 2, 3}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s1 = {1,2,3,4}
>>> s2 = {1,4,5}
>>> s1.difference(s2)
{2, 3}
>>> s2.difference(s1)
{5}
>>> s2.difference(s2)
set()
>>> sc.clear()
>>> sc
set()
>>> sc = s.copy()
>>> sc
{1, 2, 3, 4}
>>> s1.difference_update(s2)
>>> s1
{2, 3}
>>> s1.add(1)
>>> s1.add(4)
>>> s1
{1, 2, 3, 4}
>>> s1.intersection(s2)
{1, 4}
>>> s1.intersection_update(s2)
>>> s1
{1, 4}
>>> s1
{1, 4}
>>> s1
{1, 4}
>>> s2
{1, 4, 5}
>>> s1.isdisjoint(s2)
False
>>> s3 = {7}
>>> s1.isdisjoint(s3)
True
>>> s1.issubset(s2)
True
>>> s1.issubset(s1)
True
>>> s1.issuperset(s1)
True
>>> s2.issuperset(s1)
True
>>> s1.union(s2)
{1, 4, 5}
>>> s1
{1, 4}
>>> s1.symmetric_difference(s2)
{5}
>>> s2.symmetric_difference(s1)
{5}
>>> s2.update(s1)
>>> s2
{1, 4, 5}
>>> s1.update(s2)
>>> s1
{1, 4, 5}
>>> 

-- Advanced Dictionaries
- dict.viewvalues() is used to display values in dictionaries.
- dict.viewitems() is used to display items other than iter methods.
- iter methods like items(), itervalues(), iterkeys() are used to display items in dictionaries.

-- Advanced list
>>> l1 = [1,2,3]
>>> l1.append(4)
>>> l1
[1, 2, 3, 4]
>>> l1.append([5,7])
>>> l1
[1, 2, 3, 4, [5, 7]]
>>> l1.pop()
[5, 7]
>>> l1
[1, 2, 3, 4]
>>> l1.pop(2)
3
>>> l1
[1, 2, 4]
>>> l1.extend([3,5])
>>> l1
[1, 2, 4, 3, 5]
>>> l1.sort()
>>> l1
[1, 2, 3, 4, 5]
>>> l1.reverse
<built-in method reverse of list object at 0x7f695c0f51c8>
>>> l1.reverse()
>>> l1
[5, 4, 3, 2, 1]
>>> l1
[1, 2, 3, 4, 5]
>>> l1.count(1)
1
>>> l1.insert(1,0)
>>> l1
[1, 0, 2, 3, 4, 5]
>>> l1.append(0)
>>> l1
[1, 0, 2, 3, 4, 5, 0]
>>> l1.remove(0)
>>> l1
[1, 2, 3, 4, 5, 0]








 




 
